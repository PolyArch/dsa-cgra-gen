//Comment style : // or /**/
/*
Value
    definition:
        <alias:> name <:encode>
        A64 :   Add64   :   0
        M32x:   Mul32x2 :   1
    parser:
        opt(stringLiteral~":")~stringLiteral~opt(":"~"(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9]|)".r)
    description:
        alias is always optional. it is just for easy to call
        encode is necessary when it will actually be encode in compiler
        name is always necessary

Set :

        "{"~> repsep(value, ",|"+whiteSpace) <~"}"

Assignment:
        name = value | Set
*/

ADD = FU{
    Opcodes = {
        Add64 Add32x2 Add16x4 Sub64 Sub32x2 Sub16x4
    }
    Output_Routing = {
        "NE":[1,1]    "SE":[1,-1]
        "SW":[-1,-1]  "NW":[-1,1]
    }
    Mapping = Dedicated //(Single Instruction Only)
    Firing = InputArrival //(Fire on input arrival â€“ no backpressure)
};
MUL = FU {
    Opcodes = {
        Mul64 Mul32x2 Mul16x4
    }
    Output_Routing = {
        "NE":[1,1]    "SE":[1,-1]
        "SW":[-1,-1]  "NW":[-1,1]
    }
    Mapping = Dedicated
    Firing = InputArrival
};

SPC = FU{
    Opcodes = {
        Add64 Add32x2 Add16x4 Sub64 Sub32x2 Sub16x4 Mul64 Mul32x2 Mul16x4
    }
    Output_Routing = {
        "NE":[1,1]    "SE":[1,-1]
        "SW":[-1,-1]  "NW":[-1,1]
    }
    Mapping = Shared(8) //8 instructions in instruction buffer
    Firing = TriggeredInstructions //(Triggered-instructions dataflow execution)
    Size = [1,2]
};

SW = Router{
     //(NE:0 SE:1 SW:2 NW:3 N:4 E:5 S:6 W:7)
     Output_Routing = {
        "NE":[1,1]    "SE":[1,-1]
        "SW":[-1,-1]  "NW":[-1,1]
        "N":[0,1]     "E":[1,0]
        "S":[0,-1]    "W":[-1,0]
     }
     Routing = CircuitSwitched
};

Adas4(1) <-db- Adas4;

{Adas4(1) <-db- Adas4,
/*
some comment
*/
 Adas4(1) <-db- Adas4};

Adas4(1) = {Adas4(1) <-db- Adas4,
            Adas4(1) <-db- Adas4};

{Adas4(1):2,
  Adas4};

Adas4(1) = {[1,1]:0,[1,-1]:1,
 "SW":[-1,-1]:2,[1,-1]:1
 [1,-1]:1 [1,-1]:1};

     Output_Routing = {
         "NE":[1,1]    "SE":[1,-1]
         "SW":[-1,-1]  "NW":[-1,1]
     };

simple_cgra = CGRA{

    Router = SW

    // Topology defines FU and I/O locations, and connectivity

    Topology = grid2d(

        "    |     |     |    |    |   |   |     |   |     |     ",
        "    | MUL |     |ADD |    |MUL|   |ADD  |   |ADD  |     ",
        "    |     |     |    |    |   |   |     |   |     |     ",
        "    | MUL |     |ADD |    |MUL|   |ADD  |   |ADD  |     ",
        "    |     |     |    |    |   |   |     |   |     |     ",
        "    | MUL |     |ADD |    |MUL|   |ADD  |   |ADD  |     ",
        "    |     |     |    |    |   |   |     |   |     |     ",
        "    | MUL |     |ADD |    |MUL|   |ADD  |   |SPC  |     ",
        "    |     |     |    |    |   |   |     |   |     |     "

    )

    Inputs = {

        In0:{I1 --> db_0
           I2 --> db_1}

        In1:{I3 -b-> ADD_1
           I4 --> db_2}
    }

    Outputs = {
        Out0:{d_5 --> I1
         SPC_1 --> I2}
    }

    //describes the logical inputs and outputs that come from scratchpad/memory/etc...

}