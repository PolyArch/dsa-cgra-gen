
package cgra.tia.parameters

import math._
import chisel3.util.log2Ceil


object derived_parameters extends knob_parameters
 with fixed_parameters
  with conf{

  val TIA_SPM_INDEX_WIDTH:Int = log2Ceil(TIA_SPM_DEPTH)

  // Index widths.
  val TIA_INSTRUCTION_INDEX_WIDTH = log2Ceil(TIA_MAX_NUM_INSTRUCTIONS)
  val TIA_REGISTER_INDEX_WIDTH = log2Ceil(TIA_NUM_REGISTERS)

  // --- Triggered Instruction Field Widths ---
  
  val TIA_TRUE_PTM_WIDTH = TIA_NUM_PREDICATES
  val TIA_FALSE_PTM_WIDTH = TIA_NUM_PREDICATES
  val TIA_PTM_WIDTH = TIA_TRUE_PTM_WIDTH + TIA_FALSE_PTM_WIDTH
  val TIA_SINGLE_ICI_WIDTH = log2Ceil(TIA_NUM_INPUT_CHANNELS + 1)
  val TIA_ICI_WIDTH = TIA_MAX_NUM_INPUT_CHANNELS_TO_CHECK * TIA_SINGLE_ICI_WIDTH
  val TIA_TAG_WIDTH = log2Ceil(TIA_NUM_TAGS)
  val TIA_ICTB_WIDTH = TIA_MAX_NUM_INPUT_CHANNELS_TO_CHECK
  val TIA_ICTV_WIDTH = TIA_MAX_NUM_INPUT_CHANNELS_TO_CHECK * TIA_TAG_WIDTH
  val TIA_OP_WIDTH = log2Ceil(TIA_NUM_OPS)
  val TIA_SINGLE_ST_WIDTH = log2Ceil(TIA_NUM_SOURCE_TYPES)

  val TIA_ST_WIDTH = TIA_NUM_SOURCE * TIA_SINGLE_ST_WIDTH
  val TIA_SINGLE_SI_WIDTH = log2Ceil(max(TIA_NUM_REGISTERS, TIA_NUM_INPUT_CHANNELS))
  val TIA_SI_WIDTH = TIA_NUM_SOURCE * TIA_SINGLE_SI_WIDTH
  val TIA_DT_WIDTH = log2Ceil(TIA_NUM_DESTINATION_TYPES)
  val TIA_DI_WIDTH = log2Ceil(max(max(TIA_NUM_REGISTERS, TIA_NUM_OUTPUT_CHANNELS), TIA_NUM_PREDICATES))
  val TIA_OCI_WIDTH = TIA_NUM_OUTPUT_CHANNELS
  val TIA_OCT_WIDTH = TIA_TAG_WIDTH
  val TIA_ICD_WIDTH = TIA_NUM_INPUT_CHANNELS
  val TIA_TRUE_PUM_WIDTH = TIA_TRUE_PTM_WIDTH
  val TIA_FALSE_PUM_WIDTH = TIA_FALSE_PTM_WIDTH
  val TIA_PUM_WIDTH = TIA_TRUE_PUM_WIDTH + TIA_FALSE_PUM_WIDTH
  val TIA_NON_IMMEDIATE_INSTRUCTION_WIDTH = (1 + TIA_PTM_WIDTH 
                                                + TIA_ICI_WIDTH 
                                                + TIA_ICTB_WIDTH
                                                + TIA_ICTV_WIDTH
                                                + TIA_OP_WIDTH
                                                + TIA_ST_WIDTH
                                                + TIA_SI_WIDTH
                                                + TIA_DT_WIDTH
                                                + TIA_DI_WIDTH
                                                + TIA_OCI_WIDTH
                                                + TIA_OCT_WIDTH
                                                + TIA_ICD_WIDTH
                                                + TIA_PUM_WIDTH)
  val TIA_PHY_INSTRUCTION_WIDTH = TIA_NON_IMMEDIATE_INSTRUCTION_WIDTH + TIA_IMMEDIATE_WIDTH
  val TIA_MM_INSTRUCTION_PADDING_WIDTH = TIA_MM_INSTRUCTION_WIDTH - TIA_PHY_INSTRUCTION_WIDTH

  // Exposed count widths.
  val TIA_CHANNEL_BUFFER_COUNT_WIDTH = log2Ceil(TIA_CHANNEL_BUFFER_FIFO_DEPTH) + 1

  // Channel index widths.
  val TIA_INPUT_CHANNEL_INDEX_WIDTH = log2Ceil(TIA_NUM_INPUT_CHANNELS)
  val TIA_OUTPUT_CHANNEL_INDEX_WIDTH = log2Ceil(TIA_NUM_OUTPUT_CHANNELS)

  // --- debug monitor--------------------------------------------------------------------------------------

  // Set in knob parameters
  var TIA_NUM_CORE_MONITOR_WORDS:Int = 0
  if(TIA_HAS_CORE_MONITOR)
    TIA_NUM_CORE_MONITOR_WORDS = TIA_NUM_CORE_MONITOR_REGISTERS_IF_ENABLED + TIA_NUM_REGISTERS
  else
    TIA_NUM_CORE_MONITOR_WORDS = 0

  // --- Core Performance Counters ---

  // Set in knob parameters.
  var TIA_NUM_CORE_PERFORMANCE_COUNTERS:Int = 0
  if(TIA_HAS_CORE_PERFORMANCE_COUNTERS) TIA_NUM_CORE_PERFORMANCE_COUNTERS = TIA_NUM_CORE_PERFORMANCE_COUNTERS_IF_ENABLED
  else TIA_NUM_CORE_PERFORMANCE_COUNTERS = 0

  // --- Register File and Instruction Memory ---

  // MMIO address space words.
  val TIA_NUM_REGISTER_FILE_WORDS = TIA_NUM_REGISTERS
  val TIA_NUM_INSTRUCTION_MEMORY_WORDS = TIA_MAX_NUM_INSTRUCTIONS * TIA_MM_INSTRUCTION_WIDTH / TIA_MMIO_DATA_WIDTH

  // --- Scratchpad ---

  // Set in knob parameters.
  var TIA_NUM_SCRATCHPAD_WORDS:Int = 0
  if(TIA_HAS_SCRATCHPAD) TIA_NUM_SCRATCHPAD_WORDS = TIA_NUM_SCRATCHPAD_WORDS_IF_ENABLED
  else TIA_NUM_SCRATCHPAD_WORDS = 0

  // --- Core Memory Map ---

  // Memory map of an individual PE.
  val TIA_CORE_MONITOR_BASE_INDEX = 0

  var TIA_CORE_MONITOR_BOUND_INDEX:Int = 0
  if (TIA_HAS_CORE_MONITOR) TIA_CORE_MONITOR_BOUND_INDEX = TIA_NUM_CORE_MONITOR_WORDS
  else TIA_CORE_MONITOR_BOUND_INDEX = 0
  val TIA_CORE_PERFORMANCE_COUNTERS_BASE_INDEX = TIA_CORE_MONITOR_BOUND_INDEX

  var TIA_CORE_PERFORMANCE_COUNTERS_BOUND_INDEX:Int = 0
  if (TIA_HAS_CORE_PERFORMANCE_COUNTERS) TIA_CORE_PERFORMANCE_COUNTERS_BOUND_INDEX = TIA_CORE_PERFORMANCE_COUNTERS_BASE_INDEX + TIA_NUM_CORE_PERFORMANCE_COUNTERS
  else TIA_CORE_PERFORMANCE_COUNTERS_BOUND_INDEX = TIA_CORE_MONITOR_BOUND_INDEX

  val TIA_CORE_REGISTER_FILE_BASE_INDEX = TIA_CORE_PERFORMANCE_COUNTERS_BOUND_INDEX
  val TIA_CORE_REGISTER_FILE_BOUND_INDEX = TIA_CORE_REGISTER_FILE_BASE_INDEX + TIA_NUM_REGISTER_FILE_WORDS

  val TIA_CORE_INSTRUCTION_MEMORY_BASE_INDEX = TIA_CORE_REGISTER_FILE_BOUND_INDEX
  val TIA_CORE_INSTRUCTION_MEMORY_BOUND_INDEX = TIA_CORE_INSTRUCTION_MEMORY_BASE_INDEX + TIA_NUM_INSTRUCTION_MEMORY_WORDS

  val TIA_CORE_SCRATCHPAD_MEMORY_BASE_INDEX = TIA_CORE_INSTRUCTION_MEMORY_BOUND_INDEX
  var TIA_CORE_SCRATCHPAD_MEMORY_BOUND_INDEX:Int = 0
  if (TIA_HAS_SCRATCHPAD) TIA_CORE_SCRATCHPAD_MEMORY_BOUND_INDEX = TIA_CORE_SCRATCHPAD_MEMORY_BASE_INDEX + TIA_NUM_SCRATCHPAD_WORDS
  else TIA_CORE_SCRATCHPAD_MEMORY_BOUND_INDEX = TIA_CORE_SCRATCHPAD_MEMORY_BASE_INDEX

  // Core address space size.
  val TIA_NUM_CORE_ADDRESS_SPACE_WORDS = TIA_NUM_CORE_MONITOR_WORDS
  + TIA_NUM_CORE_PERFORMANCE_COUNTERS
  + TIA_NUM_REGISTER_FILE_WORDS
  + TIA_NUM_INSTRUCTION_MEMORY_WORDS
  + TIA_NUM_SCRATCHPAD_WORDS

  // --- Interconnect ---

  // Router memory words.
  var TIA_ROUTER_SETTING_MEMORY_WORDS:Int = 0
  if(TIA_SOFTWARE_ROUTER) TIA_ROUTER_SETTING_MEMORY_WORDS = 0
  else if (TIA_SWITCH_ROUTER) TIA_ROUTER_SETTING_MEMORY_WORDS = 1 + TIA_NUM_PHYSICAL_PLANES
  else TIA_ROUTER_SETTING_MEMORY_WORDS = 0

  // Physical plane index width.
  val TIA_PHYSICAL_PLANE_INDEX_WIDTH = log2Ceil(TIA_NUM_PHYSICAL_PLANES) + 1

}
